[{"body":"A driver is a software component that lets the operating system and a device communicate with each other. The main reason for writing a driver is to gain access to protected data that is available only in kernel mode. If there are security flaws in a driver, unlike user mode applications, it can lead to serious problems that SYSTEM privileges are violated.\nThere have been many efforts to improve the security of Windows drivers, but there have been many difficulties in applying effective testing techniques such as fuzzing (Fuzzing is a technique that automatically generates inputs and injects them into a program to check for bugs and software defects. It is used in various fields to examine stability and security by detecting defects that are difficult for humans to predict.) compared to userland applications.\nSince a driver is loaded into kernel memory, we must access the kernel space to examine its stability. It is very difficult to apply fuzzing to this kernel component. Especially, it is even more difficult to apply coverage-guided fuzzing to the kernel.\nAt the kernel level, the driver handles application requests in the form of a structure called IRP (I/O Request Packet). More specifically, the DispatchDeviceControl that exists inside the driver handles each routine corresponding to the IOCTL code, which is the handler code contained in the IRP sent from the outside of the driver. At this time, access to the routine is determined by various constraints such as inputBuffer contents and inputBufferLength for each routine.\nIn addition, there are cases in which the execution of other routines must precede the execution of a specific routine in the driver. The typical case mentioned above is a case where a global variable set in one routine is used in another routine. We express this situation as an ordering dependency between IOCTL routines. In order to apply fuzzing to Driver without problem, information about the driver interface is required: that satisfies the constraints and dependencies of the IOCTL code.\nEven in order to apply coverage-guided fuzzing to the kernel level, coverage measurement at the kernel level and consideration of the driver interface must be preceded. These causes have made it difficult to fuzz the kernel and driver. So, team driverThru tried to solve these two problems. As we continued our research, we found several ways to solve them, and developed a simple and fast driver fuzzing framework applying these solutions. We hope this tool is useful for improving the stability of Windows drivers and kernel environments.\nIREC Docs IRPT Docs IRCAP Docs ","link":"https://example.com/docs/","title":"Introduction"},{"body":"A variety of interesting corpus are important to improve efficiency of coverage-guided fuzzing. If we able to capture I/O communication between an application and kernel, it will be of great help to fuzzer. So we had to find a way to use IRP requests as initial seeds.\nWhat is IRCAP? \r\rIRCAP allow you to intercept all IRP requests to the target driver without any side effects. It can be used to collect interesting corpus for fuzzing and can manipulate I/O communication between an application and kernel.\n","link":"https://example.com/docs/ircap/introduction/","title":"Introduction"},{"body":"For fuzzing, it is very important to increase efficiency. Without driver's interface information, a routine that cannot be accessed occur because the constraints on the IOCTL routine cannot be resolved. This means that the coverage cannot be increasing smoothly in fuzzing. From this, we can see that driver interface information is essential for efficient driver fuzzing due to the structural characteristics of the driver.\nIn addition, the driver has different constraints for access to each of the IOCTL routines. Therefore, in order to apply the driver to the fuzzer, we have to find the contraints manually. Furthermore, since most of the drivers are distributed in the form of closed source (.sys), Reverse Engineering is required to obtain driver interface information. It is very inefficient to do this manually every time before you start fuzzing. It is very inefficient to do this manually every time before you start fuzzing. Even if this is possible, there is no guarantee that mistakes and false positives will not exist. Humans are not machines.\nWe wanted to develop a tool that can easily recovery the structure of numerous drivers to increase the efficiency of fuzzing. That is how IREC (Interface RECovery) was born. The IREC automatically extracts the driver interface and constraints such as IOCTL codes, InputBufferLength, OutBufferLength in the form of JSON. What is IREC? A cross platform framework to recover driver's communication interface. It aims to recover communication interface for fuzzing a kernel driver.\nIREC was implemented using angr and radare2, and generates json files to perform effective fuzzing. That is, it can extract the interface information and constraints of the wdm driver very easily and quickly without any further inefficient manual work. Components of IREC 1IREC 2├── test-drivers # Test drivers to verify that madcore is working. 3├── projects # Driver analysis projects 4│ ├── symbolic # Techniques using symbolic execution. 5│ ├── static # Techniques using static analysis techniques 6│ └──wdm.py # WDM driver analysis framework 7└── irec.py # Main module ","link":"https://example.com/docs/irec/introduction/","title":"Introduction"},{"body":"\u0026quot;kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels\u0026quot; noted that non-determinism due to kernel-space interrupts, kernel threads, statefulness, and similar mechanisms makes kernel fuzzing more difficult. The kernel region has a memory structure different from that of the user land, and the execution flow can be changed by various unexpected requests such as interrupts. So it is not easy to perform a fuzzing test focusing only on a specific target region.\nIn addition, instrumentation is required to receive feedback on coverage increase or decrease by executing the fuzzing routine. In the case of open source user land applications, it is possible to easily measure coverage by using a code compilation technique such as AFL, but since the Windows kernel is closed source, it is impossible to use the instrumentation technique to modify the inside of the code.\nAccordingly, IRPT borrowed the idea of using intel-PT technology in the fuzzer from kAFL to measure the increase or decrease of coverage in the kernel. In addition, we modified the KVM-PT, QEMU-PT and hypercall communication technology developed by kAFL to implement communication between the VM loaded with the target driver and the fuzzer performing the mutation.\nkAFL is a nice tool in that it enables hardware-assisted kernel fuzzing that is not dependent on the OS, but it is far from the ideal fuzzer that our pursues. The reason is that kAFL targets only a single IOCTL code. This means that the ordering dependency that exists between IOCTL routines cannot be considered.\nTherefore, we tried to develop a fuzzer that solves the problems that kAFL cannot solve. Based on driver interface information that can be easily obtained using IREC.\nWhat is IRPT? IRPT is a fuzzer specialized in a windows driver. It measures the coverage of windows kernel using Intel PT technology and resolves global data problem and IOCTL dependency. Let me explain the challenges we encountered while implementing IRPT and the solutions we came up with. History of IRPT Brute-Force OneCode Fuzzer The first fuzzer developed by the Kronl team is the Brute-Force OneCode Fuzzer. Brute-Force OneCode Fuzzer sends one IOCTL code per fuzzing routine to target driver considering only constraints such as InputBuffer and inputBufferLength obtained from IREC.\nHowever, since only one IOCTL CODE is sended in one fuzzing routine, it is difficult to expect the dependency between driver routines to be satisfied only with the payload. Furthermore, kAFL reflects only the feedback result from the most recent fuzzing routine, even though the existing routines have contributed largely to coverage extension. Although the previous fuzzing routine satisfies the ordering dependency and thus the coverage of the last executed fuzzing routine could be increased, all contributions to the previous routine are ignored when coverage feedback is reflected.\nAs such, Brute-Force OneCode Fuzzer completely relies on luck to satisfy the ordering dependency between IOCTL routines during fuzzing. Even if the fuzzer finds a crash fortunately, there is a fatal drawback that all payloads sent to target driver during fuzzing must be delivered to the driver in order to reproduce. Brute-Force MultiCode Fuzzer The second fuzzer of team Kronl developed to solve the fatal problem of Brute-Force OneCode Fuzzer is Brute-Force MultiCode Fuzzer.\n\rBrute-Force MultiCode Fuzzer decodes the payload generated by the mutation, devides it into several IOCTL codes, and sends them to target driver. As a result, it is possible to satisfy the ordering dependency between IOCTL routines by delivering only one payload to the driver. Also, in order to prevent the state of the driver from being affected by the previous fuzzing routine, we implemented reload-logic that initializes the state of the driver by reloading the driver for each fuzzing routine.\nHowever, the Brute-Force MultiCode Fuzzer also had drawbacks. Brute-Force MultiCode Fuzzer uses the method of decoding the payload into IOCTL codes and InputBeffer just before sending to target driver.\nDecoding the payload just before it is sent to the driver means that the fuzzer does not know at all the structure of the payload. (The payload just before sending to the driver is the payload that has already been mutated in the fuzzer.)\nThe fatal drawback of Brute-Force MultiCode Fuzzer is that the fuzzer performs the mutation without knowing the structure of the payload in the mutation stage. When generating a payload, the fuzzer mutates the inputs without considering the driver interface at all. This method obviously requires luck to satisfy the ordering dependency of IOCTL routines. That's why the word Brute-Force comes into the name.\nThe Kronl team determined that Brute-Force MultiCode Fuzzer was also not suitable for the ideal fuzzer to achieve our ultimate goals. We needed a more driver-friendly fuzzer to build an efficient driver fuzzing framework. IRPT Beyond sending a single payload generated by the fuzzer into multiple IOCTL codes, we wanted a fuzzer that considers the driver interface in the overall fuzzing logic. IRPT is a fuzzer for ideal driver fuzzing and solving all the problems found in the previous fuzzers.\nIRPT bundles IRP packets in a unit called IRP Program and then performs mutation for this single unit. It sends a single IRP program to the driver as a payload.\nIn addition to mutating the IOCTL code and InputBuffer values for each IRP in the program, the sequence of the IRP is also mutated. The biggest advantage of IRPT that differentiates from the two Brute-force Fuzzers is mutation 'sequence' of the IRP.\nDue to this advantage, if the dependency is satisfied with the preceding IOCTL routine and the coverage is increased in the subsequent fuzzing routine, Fuzzer understands the relationship between the routines that caused the increase in coverage and can reflect it in the next mutation. With the development of IRPT, we were able to successfully solve problems that could not be solved in existing fuzzers and realize efficient driver fuzzing.\n","link":"https://example.com/docs/irpt/introduction/","title":"Introduction"},{"body":"Get started now ","link":"https://example.com/docs/irec/","title":"IREC"},{"body":"Get started now ","link":"https://example.com/docs/irpt/","title":"IRPT"},{"body":"How to use You need to install Visual Studio and Windows Driver Kit. Once you have completed building an driver development environment, open ircap/hook.h for editing.\n1// ircap/hook.h 2#pragma once 3 4UNICODE_STRING TARGET_DEVICE_NAME = RTL_CONSTANT_STRING(L\u0026#34;\\\\Driver\\\\@@DEVICE_NAME@@\u0026#34;); 5UNICODE_STRING PROGRAM_FILE_PATH = RTL_CONSTANT_STRING(L\u0026#34;\\\\DosDevices\\\\C:\\\\program.irp\u0026#34;); Specfiy TARGET_DEVICE_NAME to the device name you want to hook. And PROGRAM_FILE_PATH is the file path where captured IRP requests are stored.\nTo capture IRP requests to target driver, follow these steps (Run cmd as administrator):\n Register a ircap.sys as a boot service.  1sc.exe create ircap binpath=ircap.sys type=kernel start=boot Reboot your computer  1reboot Run the application that loads the target driver. After running many operatons by clicking the application, unload ircap.sys manually. Then, captured IRP requests is stored in C:\\program.irp    Caution! When the capturing finished, you should remove the service. sc.exe delete ircap\n ","link":"https://example.com/docs/ircap/getting-started/","title":"Getting Started"},{"body":"We recommend python3.8 virtual environment to use IREC.\n1# make virtual environment 2$ pip install virtualenv 3$ pip install virtualenvwrapper 4 5$ virtualenv $YOUR_NAME 6$ source $YOUR_NAME/bin/activate 7 8# requirements 9$ apt install radare2 10$ pip install angr boltons argparse ipdb r2pipe ","link":"https://example.com/docs/irec/getting-started/","title":"Getting Started"},{"body":"Install IRPT Installation requires multiple components, some of which can depend on Internet connectivity and defaults of your distribution or version. It is recommended to install step by step.\n1git clone irpt 2cd ~/irpt 3./install.sh deps # check platform and install dependencies 4./install.sh perms # allow current user to control KVM (/dev/kvm) 5./install.sh qemu # git clone qemu-pt and build Qemu 6./install.sh linux # git clone kvm-pt and build Linux It is safe to re-execute any of these commands after failure, for example if not all dependencies could have been downloaded.\n1./install.sh note The final step does not automatically install the new Linux kernel but only gives some default instructions. Install according to your preference/distribution defaults, or simply follow the suggested steps above.\n1$ sudo reboot 2$ dmesg|grep VMX 3[VMX-PT] Info: CPU is supported! After reboot, make sure the new kernel is booted and PT support is detected by KVM. You must set the correct path to the Qemu binary in kAFL-Fuzzer/irpt.ini.\n1python irpt.py Launch irpt.py to get a help message with the detailed list of parameters Setting QEMU Before you launch irpt.py, you should be take a snapshot of QEMU with loader.exe. It is a file to load a target driver and agent.exe.\n1~/irpt/targets/compile_loader.sh If you prepare the binary in targets/bin/loader.exe, you can launch vm.py to take a snapshot of Qemu.\n1python vm.py Launch vm.py to get a help message with the detailed list of parameters:\n Caution! Snapshot mode is not available to access internet. You can launch vm.py with boot mode and download the binary inside the Qemu first.\n ","link":"https://example.com/docs/irpt/getting-started/","title":"Getting Started"},{"body":"IRCAP is a standalone driver which hooks DispatchDeviceControl of the target driver. Implementation 1// ircap/ircap.c 2NTSTATUS 3DriverEntry( 4\t_In_ PDRIVER_OBJECT\tDriverObject, 5\t_In_ PUNICODE_STRING\tRegistryPath 6\t) 7{ 8\t... 9\tntStatus = PsCreateSystemThread(\u0026amp;threadHandle, 10\tTHREAD_ALL_ACCESS, 11\tNULL, 12\t(HANDLE)0, 13\tNULL, 14\tThreadIRPHooker, 15\tNULL); 16 17\t... 18\tKeWaitForSingleObject(threadObject, Executive, KernelMode, FALSE, NULL); 19\t... 20} It is loaded at boot time and creates a system thread with ThreadIRPHooker routine.\n1// ircap/hook.h 2VOID 3ThreadIRPHooker( 4\t_In_ PVOID Context 5) 6{ 7\t... 8 9\tfor (i = 0; i \u0026lt; 10000; i++) { 10\tKDPRINTF(\u0026#34;[ircap.sys] try hooking (%d) \\n\u0026#34;, i); 11 12\tg_targetDriverObject = GetDriverObjectbyDeviceName(TARGET_DEVICE_NAME); 13\tif (g_targetDriverObject) 14\tbreak; 15 16\tKeDelayExecutionThread(KernelMode, FALSE, \u0026amp;Time); 17\t} 18\t... 19} This routine first obtains the driver object using GetDriverObjectbyDeviceName function. To get the driver object, it callsObReferenceObjectByName function with a device name.\n1\t// Hook a DispatchDeviceControl function. 2\tg_oriDispatchDeviceControl = g_targetDriverObject-\u0026gt;MajorFunction[IRP_MJ_DEVICE_CONTROL]; 3\tg_targetDriverObject-\u0026gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = hookDispatchDeviceControl; 4 5\tInitializeObjectAttributes(\u0026amp;ObjectAttributes, \u0026amp;PROGRAM_FILE_PATH, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL); 6\tntStatus = ZwCreateFile(\u0026amp;g_handle, GENERIC_WRITE, \u0026amp;ObjectAttributes, 7\t\u0026amp;IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF, 8\tFILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); Then, it overwrites DriverObject-\u0026gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] with hookDispatchDeviceControl function and creates a file to save IRP requests.\n1NTSTATUS 2hookDispatchDeviceControl( 3\tPDEVICE_OBJECT DeviceObject, 4\tPIRP Irp 5) 6 7{ 8\t... 9 10\tprogramInfo[0] = irpSp-\u0026gt;Parameters.DeviceIoControl.IoControlCode; 11\tprogramInfo[1] = inBufLength; 12\tprogramInfo[2] = outBufLength; 13 14\tZwWriteFile(g_handle, NULL, NULL, NULL, \u0026amp;IoStatusBlock, (PVOID)programInfo, sizeof(programInfo), NULL, NULL); 15\tZwWriteFile(g_handle, NULL, NULL, NULL, \u0026amp;IoStatusBlock, (PVOID)inBuf, inBufLength, NULL, NULL); 16 17\treturn g_oriDispatchDeviceControl(DeviceObject, Irp); 18} The hookDispatchDeviceControl function saves a serialized IRP request to the file and forwards it to the original DispatchDeviceControl function.\n","link":"https://example.com/docs/ircap/internals/","title":"Core concepts"},{"body":"IREC project was originally designed to recover I/O Communication interface of WDM (Windows Driver Model) driver. The WDM interface includes the following information.\n\r All control codes implemented in the driver. InputBufferLength, OutputBufferLength constraints for each control code.  Section below describes how to recover an interface. Perhaps this is hard to understand if you don't know the concept of symbolic extension or angr. Find DispatchDeviceControl function DispatchDeviceControl function is a dispatcher handles IRP with I/O control code. When a user application calls the Win32 function DeviceIoControl, This function is invoked and handles a user request.\n1if ( !v47 ) 2{ 3 v3-\u0026gt;MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = \u0026amp;sub_180002470; 4 v3-\u0026gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = \u0026amp;sub_180002470; // DispatchDeviceControl 5 v3-\u0026gt;MajorFunction[IRP_MJ_CLOSE] = \u0026amp;sub_180002470; 6} DispatchDeviceControl function is registered at front of DriverEntry. So we set a memory breakpoint on DriverObject→Majorfunction[MJ_DEVICE_CONTROL] using angr.\n1# projects/wdm.py 2def find_DispatchDeviceControl(self): 3 ... 4\t# Set a breakpoint on DriverObject-\u0026gt;MajorFuntion[MJ_DEVICE_CONTROL] 5\tstate.inspect.b(\u0026#39;mem_write\u0026#39;,when=angr.BP_AFTER, 6\tmem_write_address=arg_driverobject+DispatchDeviceControl_OFFSET, 7\taction=self.set_major_functions) 8 ... Now, we can get an address of DispatchDeviceControl by symbolic execution. Obtain all control codes To request IRP, we have to know what I/O control codes are implemented in the DispatchDeviceControl function.\n\r\rAs you know, DispatchDeviceControl handles IRP requests by I/O control codes. And these dispatch routines are mostly switch statement or if-else statement.\n1# explore_technique.py 2class SwitchStateFinder(angr.ExplorationTechnique): 3 def __init__(self, case): 4 ... 5 6 def setup(self, simgr): 7 ... 8 9 def step(self, simgr, stash=\u0026#39;active\u0026#39;, **kwargs): 10 simgr = simgr.step(stash=stash, **kwargs) 11 12 if stash == \u0026#39;active\u0026#39; and len(simgr.stashes[stash]) \u0026gt; 1: # [1] 13 saved_states = [] 14 for state in simgr.stashes[stash]: 15 try: 16 io_code = state.solver.eval_one(self._case) # [2] 17 if io_code in self.switch_states: # duplicated codes 18 continue 19 20 self.switch_states[io_code] = state 21 except: 22 saved_states.append(state) 23 24 simgr.stashes[stash] = saved_states # [3] 25 26 return simgr 1# wdm.py 2def recovery_ioctl_interface(self): 3 ... 4 # [1] 5 state_finder = explore_technique.SwitchStateFinder(io_stack_location.fields[\u0026#39;IoControlCode\u0026#39;]) 6 simgr.use_technique(state_finder) 7 simgr.run() 8 ... In this situation, we customized the behavior of a simulation manager, called exploration techniques. It sets a Symbolic Variable first to IO_STACK_LOCATION.IoControlCode. Running the symbolic execution, we check if the current state is divided into several states [1]. (A state is divided when encounter switch or if statement) And then, if the Symbolic Variable IoControlCode is narrowed down to one possible value [2], we save this state and exclude from the active stash [3]. Now, we got all I/O control codes and states.\nInspect constraints Constraints include the following variables.\n InputBuffer OutputBuffer InputBufferLength OutputBufferLength  In order to get constraints for each control code, we use jump_guards of the history plugin. It is a listing of the constraints guarding each of the branches that the state has encountered.\n1# wdm.py 2def recovery_ioctl_interface(self): 3 ... 4 for ioctl_code, case_state in switch_states.items(): 5 def get_constraint_states(st): 6 ... 7 simgr = self.project.factory.simgr(st) 8 9 for i in range(10): 10 simgr.step() 11 12 for state in simgr.active: 13 for constraint in state.history.jump_guards: 14 if \u0026#39;BufferLength\u0026#39; in str(constraint) and \\ 15 str(constraint) not in preconstraints: 16 yield state 17 18 # Inspect what constraints are used. 19 constraint_states = get_constraint_states(case_state) Until the constraint first appear, we step forward the state which is obtained from the previous stage.\n\r\rThen, we'll get two states named sat and unsat. Only one of these has the valid conditions that we want to know.\n1# wdm.py 2def recovery_ioctl_interface(self): 3 ... 4 constraint_states = get_constraint_states(case_state) 5 6 try: 7 sat_state = next(constraint_states) 8 unsat_state = next(constraint_states) 9 except: 10 ... 11 12 simgr_sat = self.project.factory.simgr(sat_state) 13 simgr_unsat = self.project.factory.simgr(unsat_state) 14 15 def determine_unsat(): 16 for _ in range(30): 17 simgr_sat.step() 18 simgr_unsat.step() 19 20 if len(simgr_sat.active) == 0: 21 yield False 22 elif len(simgr_unsat.active) == 0: 23 yield True 24 25 if not next(determine_unsat()): 26 sat_state, unsat_state = unsat_state, sat_state It need to determine which of two states meets the condition. Many algorithms can be used for this determination. We assume that the state of the wrong condition (unsat) ends before the correct condition (sat). Because all unsat has to do is return nt error. This algorithm is quite accurate and fast.\n1# Get valid constraints. 2def get_valid_constraints(sat_state, unsat_state): 3 simgr = self.project.factory.simgr(sat_state) 4 5 for _ in range(10): 6 simgr.step() 7 8 for states in list(simgr.stashes.values()): 9 for state in states: 10 if unsat_state.addr not in state.history.bbl_addrs: 11 return states 12 13sat_state = get_valid_constraints(sat_state, unsat_state) When sat, unsat is determined, we can get all the correct conditions of constraints using bbl_addrs. bbl_addrs of history plugin is a listing of the basic block addresses executed by the state. So you just need to find a state that doesn't go through unsat's address.\n","link":"https://example.com/docs/irec/internals/","title":"Core concepts"},{"body":"Coverage-guided fuzzing The dynamic instrumentation that a closed-source binary requires can be generated using DynamoRIO. Also, pe-afl or syzygy can be used for static instrumentation. But these projects are designed for application's instrumentation not a kernel. So we started looking for a project that can measure the coverage of Windows kernel.\nA few days later, we found kAFL that uses Intel PT technology and decided to modify it to support Windows driver.\nQEMU is possible to create multiple hardware-supported virtual machines (VMs) on a single logical CPU through Intel’s hardware virtualization technology, Intel VT-x. In this case, each VM has a set of its own vCPUs and Intel Processor Tracing(Intel PT) allows you to trace the execution flow of it. So we can get all the execution flow of QEMU's guest and also Windows kernel. Fuzzing a Windows driver Even if it is possible to measure the coverage of the Window driver, there's a lot of challenges to solve.\n  Lack of information about IOCTL interface.\nIf we don't know about IOCTL interface like I/O control codes and InputBufferLength in advance, performance of fuzzing will drop dramatically.\n→ IREC can recover all the details of IOCTL interface. Then, IRPT mutates and generates test cases based on this interface.\n  Difficult to collect interesting seeds.\nAn application will communicates with Windows driver via DeviceIoControl function. If you want to trace all about communication, it needs to hook IOCTL dispatcher function.\n→ IRCAP can capture all IRP packets and store them by serialized format. Then, IRPT parses and uses it as an initial test case.\n  The previous IRP request may affect the next due to global variables, lock, mutex or etc. We call these types of problems IOCTL Dependency (or dependency). To solve the dependency problem, We searched for existing studies, but we couldn't find any related materials. Therefore, we had to research and develop a framework ourselves that could flexibly respond to these problems. The below section describes the internal of the framework and how to solve the dependency completely.   Components of IRPT \r\rIRPT consists of fuzzer, mutator, reproducer, optimizer, hypervisor and corpus database. Fuzzer brings a test case from Corpus database and sends mutated test case to Hypervisor via shared memory. The hypervisor measures its coverage and checks if new coverage or crash has been found. If the new coverage has been found, Optimizer verifies that a new coverage is measured again and sends to corpus database after minimization. If a crash is detected, Reproducer verifies that the crash occurs again and saves it as a file. Hypervisor The hypervisor runs QEMU which emulates Windows kernel and kvm (Kernel-based Virtual Machine). While the QEMU emulates an agent which actually communicates with Windows kernel, the kvm traces execution flow of kernel.\nHow to communicate with Fuzzer 1# common/qemu.py 2class qemu: 3 def __init__(self, qid, config, debug_mode=False, notifiers=True): 4 ... 5 self.cmd += ... 6 \u0026#34; -chardev socket,server,nowait,path=\u0026#34; + self.control_filename + \\ 7 \u0026#34;,id=irpt_interface \u0026#34; + \\ 8 \u0026#34;-device irpt,chardev=irpt_interface\u0026#34; + \\ When the fuzzer starts QEMU, It can create a socket that communicates with QEMU by specifying the chardev option. The fuzzer sends a byte character to this socket whenever it wants to call a specific operation of the QEMU. When the QEMU receives a byte from the fuzzer, irpt_guest_receive function below is invoked. 1// pt/interface.c 2static void irpt_guest_receive(void *opaque, const uint8_t * buf, int size){ 3\tkafl_mem_state *s = opaque;\t4\tfor(int i = 0; i \u0026lt; size; i++){ 5\tswitch(buf[i]){ 6\tcase KAFL_PROTO_RELEASE: 7\tsynchronization_unlock(); 8\tbreak; 9\t10\t... 11\tcase KAFL_PROTO_FINALIZE: 12\tsynchronization_disable_pt(qemu_get_cpu(0)); 13\tsend_char(\u0026#39;F\u0026#39;, s); 14\tbreak; 15\t... 16} It is possible to send a byte to the fuzzer by send_char function, but it is usually used to notify if the requested operation did well. Shared memory 1// pt/interface.c 2static void pci_kafl_guest_realize(DeviceState *dev, Error **errp){ 3\t... 4\t5\tif (s-\u0026gt;data_bar_fd_0 != NULL) 6\tkafl_guest_create_memory_bar(s, 1, PROGRAM_SIZE, s-\u0026gt;data_bar_fd_0, errp); 7\tif (s-\u0026gt;data_bar_fd_1 != NULL) 8\tkafl_guest_create_memory_bar(s, 2, PAYLOAD_SIZE, s-\u0026gt;data_bar_fd_1, errp); 9\t... 10} 11 12... 13static Property kafl_guest_properties[] = { 14\tDEFINE_PROP_CHR(\u0026#34;chardev\u0026#34;, kafl_mem_state, chr), 15\tDEFINE_PROP_STRING(\u0026#34;shm0\u0026#34;, kafl_mem_state, data_bar_fd_0), 16\tDEFINE_PROP_STRING(\u0026#34;shm1\u0026#34;, kafl_mem_state, data_bar_fd_1), 17\tDEFINE_PROP_STRING(\u0026#34;bitmap\u0026#34;, kafl_mem_state, bitmap_file), 18\tDEFINE_PROP_STRING(\u0026#34;coverage_map\u0026#34;, kafl_mem_state, coverage_map_file), 19\t... 20\tDEFINE_PROP_END_OF_LIST(), 21}; QEMU creates shared memories to send and receive large data.\nThere are the four shared memories:\n shm0 : to receive a data contains agent and driver binary. shm1 : to receive serialized IRP requests. bitmap : used to check that program reaches the new execution path. coverage_map : used to track the execution flow of program.  A detailed description of these shared memories is described later sections. write_virtual_memory, read_virtual_memory 1// pt/memory_access.h 2bool read_virtual_memory(uint64_t address, uint8_t* data, uint32_t size, CPUState *cpu); 3bool write_virtual_memory(uint64_t address, uint8_t* data, uint32_t size, CPUState *cpu); It can access any virtual memory on guest even a kernel space. QEMU uses these functions and shared memory to deliver a data received from the fuzzer to agent. Agent It first registers the target driver as a service. And it loads and opens the device, which calls DeviceIoControl function or other command sent from fuzzer.\nHow to communicate with Hypervisor 1// kafl_user.h 2static void kAFL_hypercall(uint64_t rbx, uint64_t rcx){ 3\tuint64_t rax = HYPERCALL_KAFL_RAX_ID; 4 asm volatile(\u0026#34;movq %0, %%rcx;\u0026#34; 5\t\u0026#34;movq %1, %%rbx;\u0026#34; 6\t\u0026#34;movq %2, %%rax;\u0026#34; 7\t\u0026#34;vmcall\u0026#34; 8\t: 9\t: \u0026#34;r\u0026#34; (rcx), \u0026#34;r\u0026#34; (rbx), \u0026#34;r\u0026#34; (rax) 10\t: \u0026#34;rax\u0026#34;, \u0026#34;rcx\u0026#34;, \u0026#34;rbx\u0026#34; 11\t); 12} 1// agent.cpp 2... 3int main(int argc, char** argv){ 4 /* submit the guest virtual address of the payload buffer */ 5 hprintf(\u0026#34;[+] Submitting buffer address to hypervisor...\u0026#34;); 6 kAFL_hypercall(HYPERCALL_KAFL_GET_PAYLOAD, (UINT64)payload_buffer); 7\t... 8} When the agent wants to communicate with the hypervisor(QEMU) directly, it requests the hypercall with the syscall number and arguments. Then, QEMU process the hypercall according to the syscall number.\nAnti IOCTL filter \rAbove hex-ray shows that the current process ID is used for session key to block invalid requests. Such a filtering usually exists in protection software like anti-virus, DRM and etc. We have implemented bypass for GetCurrentProcessId and GetCurrentThreadId function.\n1// target/src/agent.cpp 2... 3case ANTI_IOCTL_FILTER: 4\tpsGetCurrentProcessId = resolve_KernelFunction(sPsGetCurrentProcessId); 5\tpsGetCurrentThreadId = resolve_KernelFunction(sPsGetCurrentThreadId); 6 7\t*(uint32_t*)(ioctl_filter_bypass + 1) = GetCurrentProcessId(); 8\tkAFL_hypercallEx(HYPERCALL_KAFL_MEMWRITE, psGetCurrentProcessId + 0x10, (uint64_t)ioctl_filter_bypass, sizeof(ioctl_filter_bypass)); 9\t*(uint32_t*)(ioctl_filter_bypass + 1) = GetCurrentThreadId(); 10\tkAFL_hypercallEx(HYPERCALL_KAFL_MEMWRITE, psGetCurrentThreadId + 0x10, (uint64_t)ioctl_filter_bypass, sizeof(ioctl_filter_bypass)); 11\tbreak; 12\t} \r\rWe can insert shellcode into kernel memory using write_virtual_memory function. The patched function returns only zero if the current process ID is the same as the agent's ID. IRP Program \r\rIRP Program is a basic unit of all components of IRPT. It contains several IRP classes corresponding to DeviceIoControl call. The reason why we use this structure as a unit is to solve the following problems. We will call it program from now on.\nDependency reset To avoid previous IRP request, we have to reload a driver at a certain point.\n1# fuzzer/process/process.py 2\tdef execute(self, program): 3\tself.__set_current_program_with_count(program) 4\tself.q.reload_driver() # reload! 5\t6\tfor i in range(len(self.cur_program.irps)): 7\tif self.execute_irp(i): 8\treturn True 1def _revert_driver(self): 2 try: 3 self.send_irp(IRP(0, 0, 0, command=qemu_protocol.DRIVER_REVERT)) 4 except ConnectionResetError: 5 sys.exit() 6 7def _reload_driver(self): 8\tself.send_irp(IRP(0, 0, 0, command=qemu_protocol.DRIVER_RELOAD)) IRPT reloads a target driver in every execution of program via qemu._reload_driver function. For the target driver can't reload manually, we provide revert option. However, this option is experimental and unstable for some drivers.\n1void handle_hypercall_irpt_ip_filtering(struct kvm_run *run, CPUState *cpu) { 2\t... 3\tif (start \u0026amp;\u0026amp; end) { 4\tuint64_t start = run-\u0026gt;hypercall.args[0]; 5\tuint64_t end = run-\u0026gt;hypercall.args[1]; 6\t... 7 8\tread_virtual_memory(driver_info.imagebase, driver_info.image, driver_info.imagesize , cpu); 9\tpt_enable_ip_filtering(cpu, filter_id, start, end, false); 10\treturn; 11\t} 12\t// Revert mode 13\twrite_virtual_memory(driver_info.imagebase, driver_info.image, driver_info.imagesize , cpu); 14\t} 15} It just copies the entire image of the target driver right after the driver is loaded. And pastes it when the dependency reset is needed.\nOrder dependency If we operate the fuzzing process with program, the fuzzer can recognize the order of the IRP requests.\n1# wdm/program.py 2class Program: 3\t... 4\tdef mutate(self, corpus_programs): 5\t... 6\tif rand.oneOf(5) and self.__splice(corpus_programs): 7\tmethod = \u0026#34;splice\u0026#34; 8\telif rand.oneOf(10) and self.__swapIRP(): 9\tmethod = \u0026#34;swapIRP\u0026#34; 10\telif rand.oneOf(10) and self.__insertIRP(corpus_programs): 11\tmethod = \u0026#34;insertIRP\u0026#34; 12\telif rand.oneOf(20) and self.__removeIRP(): 13\tmethod = \u0026#34;removeIRP\u0026#34; 14\t15\tself.set_state(method) 16\treturn method The mutation of the order allows fuzzer to know which order is interesting. Details of mutation algorithm is described in the following sections. Mutator The mutator is designed to generate various types of IRP. We will continue to discuss and develop mutation strategies reflecting characteristics of the Windows driver. There are three main categories of mutation.\n1. Program mutation It is used to mutate structure of program and divided into four sub routines below. Each routine has a random probability.\nsplice : Merges with random IRP Program. (about 5%) swapIRP : Swap the location of two IRP. (about 9.5%) insertIRP : Insert IRP at the random location. (about 8.55%) removeIRP : Remove IRP at the random location. (about 15.39%) 2. deterministic Most of its strategies come from afl's deterministic. When the program goes through fuzzing steps at first, and tweaks to some regions in the IRP are observed to have effect on the execution path, except in these two cases maybe excluded from deterministic logic - and the fuzzer may proceed straight to havoc.\nThe deterministic strategies include below and most of them tweak InputBuffer of IRP: Walking bit and byte flips : Sequential bit and byte flips with varying lengths and stepovers (Same as afl) Simple arithmetics : Sequential addition and subtraction of small integers (Same as afl) Known integers : Sequential insertion of known interesting integers (Same as afl) One day : Interesting edge cases only can occur in IOCTL. 3. havoc As you know, deterministic strategies are not exhaustive. havoc calculates a more diverse and random value reflecting the characteristics of IOCTL communication.\n1# fuzzer/technique/havoc.py 2def mutate_seq_8_bit_rand8bit(self, index): 3 ... 4 for _ in range(32): 5 value = in_range_8(rand.Intn(0xff)) 6 if (is_not_bitflip(orig ^ value) and 7 is_not_arithmetic(orig, value, 1) and 8 is_not_interesting(orig, value, 1, 1)): 9 data[i] = value 10 if self.execute_irp(index): 11 return True Check if it can be made by deterministic strategies before sending to agent, so duplicated test cases are not executed. T he havoc strategies include below: Walking random bytes insertion : Sequential random bytes insertion with varying lengths. Random integers : Sequential insertion of random integers. Random buffer length : Insertion of random InputBufferLength and OutputBufferLength. Bruteforce IRP requests : Send a random program many times. Optimizer It validates a mutated test case once again and leaves only the programs that affect the new coverage.\nValidation 1# wdm/optimizer.py 2def optimize(self): 3 ... 4\t# quick validation. 5 self.q.turn_on_coverage_map() 6 new_res = self.__execute(program.irps) 7 self.q.turn_off_coverage_map() 8 if not new_res: 9 continue 10 11 old_array = old_res.copy_to_array() 12 new_array = new_res.copy_to_array() 13 if new_array != old_array: 14 continue The Intel PT trace consists of a sequence of packets and FUP (Flow Update Packet) for asynchronous event. Even if the program has no effect on the execution path, the bitmap can be different due to FUP. So the optimizer compares original bitmap with the newly calculated bitmap.\nMinization 1# wdm/optimizer.py 2def optimize(self): 3\t... 4\twhile i \u0026lt; len(program.irps) and len(program.irps) \u0026gt; 1: 5\texec_res = self.__execute(program.irps[:i] + program.irps[i+1:]) 6\tif not exec_res: 7\tcontinue 8\t9\tdependent = False 10\tfor index in new_bytes.keys(): 11\tif exec_res.cbuffer[index] != new_bytes[index]: 12\tdependent = True 13\tbreak 14\tif not dependent: 15\tfor index in new_bits.keys(): 16\tif exec_res.cbuffer[index] != new_bits[index]: 17\tdependent = True 18\tbreak 19\tif not dependent: 20\tdel program.irps[i] 21\telse: 22\ti += 1 After validation, the optimizer minimizes a mutated program by removing non-dependent IRP. (dependent meaning it effects on the new execution path) Corpus database The number of programs will be increased gradually as the fuzzer continues to run. Some of them may have duplicated coverage or won't need to mutate anymore.\ncoverage map 1void pt_bitmap(uint64_t addr){ 2\t... 3\tif(bitmap){ 4\taddr -= module_base_address; 5\tif (is_coveraged \u0026amp;\u0026amp; coverage_map) { 6\tcoverage_map[addr % (kafl_coverage_map_size/sizeof(uint16_t))] = ++coverage_id; 7\t} 8\t... 9\tbitmap[transition_value \u0026amp; (kafl_bitmap_size-1)]++; 10\t} 11\tlast_ip = addr; 12} We use a coverage_map containing execution flow of the program to determine if two programs has the same coverage.\n1def turn_on_coverage_map(self): 2 self.__debug_send(qemu_protocol.COVERAGE_ON) 3 4def turn_off_coverage_map(self): 5\tself.__debug_send(qemu_protocol.COVERAGE_OFF) To avoid performance bottleneck, perform related operations only after calling the turn_on_coverage_map function.\nDeduplication The corpus database has two groups of the program, programs and unique_programs. unique_programs is a group that has unique execution flows.\n1# wdm/database.py 2def __unique_selection(self, new_programs): 3\t... 4 for new_program in new_programs: 5 new_coverage_set = set(new_program.coverage_map) 6 7 # Remove a duplicated unique program. 8 i = 0 9 while i \u0026lt; len(self.unique_programs): 10 old_coverage_set = set(self.unique_programs[i].coverage_map) 11 12 count = 0 13 for address in new_coverage_set: 14 if address in old_coverage_set: 15 count += 1 16 17 if len(old_coverage_set) == count: 18 del self.unique_programs[i] 19 else: 20\ti += 1 21 self.unique_programs.append(new_program) The __unique_selection function is invoked when a new interesting program finished optimizing. It keeps group to have only unique programs using coverage_map.\nScoring In order to prioritize unique programs, we compute probability map with depth of mutation(level), number of executions(exec_count) and number of code blocks executed.\n1# wdm/database.py 2def update_probability_map(self): 3 ... 4 for uniq_program in self.unique_programs: 5 score = REMOVE_THRESHOLD 6 score += uniq_program.get_level() * 20 7 score += len(set(uniq_program.coverage_map)) * 2 8 score -= uniq_program.get_exec_count() * 20 9 score = max(score, 1) 10 11 total_score += score 12 self.probability_map.append(score) 13 14 for i, uniq_program in enumerate(self.unique_programs): 15 self.probability_map[i] /= total_score 16... 17def get_next(self): 18 if len(self.unique_programs) == 0 or rand.oneOf(10): 19 program = random.choice(self.programs) 20 else: 21 program = np.random.choice(self.unique_programs, p=self.probability_map) 22 return program We should continue to find the optimal probability equation. Reproducer It is responsible for crash reproduction. Because, we run the Windows kernel under the QEMU, occasionally encounters errors and stops while communicating with the fuzzer. So we should have to validate crashing test case once again.\nDe-duping crashes 1# wdm/reproducer.py 2def reproduce(self): 3\t... 4\tfor i in range(len(program.irps)): 5\texec_res = self.q.send_irp(program.irps[i]) 6\t7\tif exec_res.is_crash(): 8\tlog(\u0026#34;[*] %sfound!!\u0026#34; % exec_res.exit_reason, \u0026#34;CRASH\u0026#34;) 9\t... 10\t11\tunique = False 12\tfor address in exec_res.coverage_to_array(): 13\tif address not in self.crash_map: 14\tunique = True 15\tself.crash_map[address] = True The crash_map has all the listing of the crashing programs' block addresses. If the listing of the newly found crashing programs' addresses contain an address that is not included in crash_map, it is classified as a unique crash.\n","link":"https://example.com/docs/irpt/internals/","title":"Core concepts"},{"body":"Get started now ","link":"https://example.com/docs/ircap/","title":"IRCAP"},{"body":"Kronl Project The project to research driver security and develop an automated testing framework named Kronl. It consists of IREC, IRPT and IRCAP.\nWhy the driver? A driver is a software component that lets the operating system and a device communicate with each other. The main reason for writing a driver is to gain access to protected data that is available only in kernel mode. If there are security flaws in a driver, unlike user mode applications, it can lead to serious problems that SYSTEM privileges are violated.\nRead the Docs Download\n\r\r\r\r","link":"https://example.com/","title":"Kronl"}]